---
title: 真·Docker 自动部署个人博客
date: 2020-03-18 16:41:53
description: Docker 自动部署个人博客
categories: [Docker篇]
tags: [Docker]
---

<!-- more -->

### 何为 `真`
以前我都是服务器上执行定时任务,在凌晨的时候 pull 博客仓库在 hexo 编译, 在上传到 github 静态资源库, 在 pull 静态资源库到 nginx 目录下,这样实现个人博客的发布

真: 放弃定时任务, 采用 github 的钩子, 在博客仓库有 push 行为时,立马执行上述操作, 以前直接在服务器上写的脚本来执行,这次决定将这些操作打包成一个 docker 镜像, 随时随地可部署

避免了部署还需要配置定时任务和写一批脚本的问题.

### 步骤
1. 以 Ubuntu 18.04 为基础镜像,进行镜像的制作
2. docker run -it -name blog-auto-publish ubuntu:18.04 /bin/bash
3. apt update
4. apt install git
5. apt install vim
6. rm -rf /etc/apt/sources.list
7. vim /etc/apt/sources.list

```shell script
    deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
    deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
    
    deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
    deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
    
    deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
    deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
    
    deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
    deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
    
    deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
    deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse

```

8. apt update
9. apt install curl
10. curl -sL https://deb.nodesource.com/setup_13.x | bash 
11. apt-get install -y nodejs
12. npm install hexo -g
13. apt install nginx
14. apt install fcgiwrap


### 新建目录
mkdir /my-blog
mkdir -p /my-blog/bash
mkdir -p /my-blog/logs

### 克隆仓库
git clone https://github.com/JoyLau/blog.git

cd blog

npm install

### 建立命令
vim /my-blog/bash/init.sh

vim init.sh

```shell script
    #!/usr/bin/env bash
    chown -R www-data:www-data /my-blog/* && service fcgiwrap start && service nginx start && tail -f -n 500 /my-blog/logs/publish.log

```

vim /my-blog/bash/pull-deploy.sh

```shell script
    #! /usr/bin/env bash
    cd /my-blog/blog && \
    ## git checkout -- _config.yml && \
    git pull && \
    echo `pwd` && \
    ## update config
    ## sed -i "s/https:\/\/name:password@github.com\/JoyLau\/blog-public.git/https:\/\/$GITHUB_REPO_USERNAME:$GITHUB_REPO_PASSWORD@github.com\/$GITHUB_REPO_USERNAME\/$GITHUB_REPO_NAME.git/g" _config.yml && \
    ## hexo clean && \
    hexo g
    ## hexo d

```

vim /my-blog/bash/publish.sh
 
```shell script
    #!/bin/bash
    echo "Content-Type:text/html"
    echo ""
    echo "ok"
    /my-blog/bash/pull-deploy.sh>/my-blog/logs/publish.log

```

### 配置 nginx
vim /etc/nginx/sites-available/default 

```nginx
    server {
        listen 80 default_server;
        listen [::]:80 default_server;

        # SSL configuration
        #
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;
        #
        # Note: You should disable gzip for SSL traffic.
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        root /my-blog/blog/public;
        
        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        server_name _;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }

        }

        server {
                listen 8080 default_server;
                listen [::]:8080 default_server;
        
                root /my-blog/bash;
        
                server_name _;
        
                location ~ ^/.*\.sh  {
                  gzip off;
                  fastcgi_pass  unix:/var/run/fcgiwrap.socket;
                  include fastcgi_params;
                  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                }
        }


```

nginx -t 检查错误


### Dockfile
```text
    FROM nas.joylau.cn:5007/joy/blog.joylau.cn:1.0
    
    LABEL maintainer="blog.joylau.cn"
    
    ENV GITHUB_REPO_USERNAME ""
    ENV GITHUB_REPO_PASSWORD ""
    ENV GITHUB_REPO_NAME ""
    ENV REPO_INFO ""
    
    EXPOSE 80
    
    EXPOSE 8080
    
    CMD ["sh", "/my-blog/bash/init.sh"]
```

打包镜像:
docker build -t nas.joylau.cn:5007/joy/blog.joylau.cn:1.0 .

打包后镜像大小为: 294 MB

### 使用
docker run -p 8081:80 -p 8082:8080 -d --name blog.joylau.cn nas.joylau.cn:5007/joy/blog.joylau.cn:1.0


### 备注
1. 80 端口提供的服务为 blog 页面
2. 8080 端口提供的服务为执行 shell 命令
3. 提供 webhook 为 http://host:port/publish.sh ,通过请求这个请求来更新博客
4. 查看日志文件有 /my-blog/logs/publish.log 和 nginx 的日志文件 /var/log/nginx/error.log

### 后续优化备忘
1. 删除原来的 /var/log/nginx/error.log 日志里的错误信息，现有的错误信息是是测试使用产生的
2. 在镜像里就执行一边 chown -R www-data:www-data /my-blog/* , 否则的话容器刚启动的时候会很慢， 可以不执行 hexo g ,使用 hexo s --watch 实时监听文件变化，也不需要 nginx 了，开启 --debug 参数打印详细日志信息 
3. 考虑将 publish.sh 的最后一行命令不等待执行完就返回，现在的情况是部署到配置较低的机器上执行很慢，会导致请求超时，虽然不影响执行结果
4. 配置好容器内的时区，使得日志的时间戳更明显
